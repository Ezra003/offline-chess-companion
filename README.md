# Documentation for Ezra003/offline-chess-companion

## 1. Introduction

This document provides a comprehensive overview and detailed explanation of the `Ezra003/offline-chess-companion` GitHub repository. The project is a web-based offline chess application designed to be played against an AI or another local player. It features a robust chess engine, an AI opponent with adjustable difficulty, and a user-friendly interface built with modern web technologies.

The primary goal of this documentation is to serve as a guide for new developers, enabling them to understand the project's architecture, core functionalities, implementation details, and dependencies. Each significant component and feature will be dissected, with explanations of the underlying code and design choices.

### 1.1 Project Overview

The `offline-chess-companion` is a single-page application (SPA) that offers a complete chess experience. Users can:

*   Play against an AI opponent with varying difficulty levels (Easy, Medium, Hard).
*   Play a local two-player game.
*   Utilize a chess clock with different modes (Blitz, Rapid, No Clock).
*   Customize board themes and piece styles.
*   View move history and captured pieces.
*   Import and export games using Portable Game Notation (PGN).
*   Undo and redo moves.

### 1.2 Target Audience

This documentation is tailored for developers who are new to the `offline-chess-companion` project. It assumes a basic understanding of web development concepts, including HTML, CSS, JavaScript/TypeScript, and React. Familiarity with chess rules and notation will also be beneficial for understanding the chess-specific logic.

## 2. Project Structure

The repository follows a standard modern web application structure, primarily organized around a `src` directory for source code and a `public` directory for static assets. Below is a breakdown of the key directories and files:

```
/offline-chess-companion
├── public/
│   ├── favicon.ico
│   ├── placeholder.svg
│   └── robots.txt
├── src/
│   ├── App.css
│   ├── App.tsx
│   ├── components/
│   │   ├── chess/
│   │   │   ├── Board.tsx
│   │   │   ├── CapturedPieces.tsx
│   │   │   ├── ChessTimer.tsx
│   │   │   ├── GameControls.tsx
│   │   │   ├── MoveList.tsx
│   │   │   ├── NewGameDialog.tsx
│   │   │   ├── PGNDialog.tsx
│   │   │   ├── PieceDisplay.tsx
│   │   │   ├── PromotionDialog.tsx
│   │   │   ├── SettingsPanel.tsx
│   │   │   └── SquareComponent.tsx
│   │   └── ui/ (... Shadcn UI components)
│   │       └── button.tsx
│   ├── engine/
│   │   ├── AIEngine.ts
│   │   ├── ChessEngine.ts
│   │   └── types.ts
│   ├── hooks/
│   │   ├── use-mobile.tsx
│   │   └── use-toast.ts
│   ├── lib/
│   │   └── utils.ts
│   ├── main.tsx
│   ├── pages/
│   │   ├── Index.tsx
│   │   └── NotFound.tsx
│   ├── test/
│   │   ├── example.test.ts
│   │   └── setup.ts
│   └── vite-env.d.ts
├── .eslintrc.cjs
├── bun.lockb
├── components.json
├── eslint.config.js
├── index.html
├── package-lock.json
├── package.json
├── postcss.config.js
├── README.md
├── tailwind.config.ts
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
├── vite.config.ts
└── vitest.config.ts
```

*   **`public/`**: Contains static assets like `favicon.ico`, `placeholder.svg`, and `robots.txt`. These files are served directly by the web server.
*   **`src/`**: The core source code of the application.
    *   **`components/`**: Reusable React components.
        *   **`chess/`**: Chess-specific UI components like `Board`, `MoveList`, `ChessTimer`, etc.
        *   **`ui/`**: UI components generated by Shadcn UI, providing a consistent design system.
    *   **`engine/`**: Contains the core chess logic and AI implementation.
        *   **`ChessEngine.ts`**: The main chess engine responsible for game rules, move generation, and state management.
        *   **`AIEngine.ts`**: Implements the AI opponent's logic.
        *   **`types.ts`**: TypeScript type definitions for chess pieces, board, moves, game state, and settings.
    *   **`hooks/`**: Custom React hooks for encapsulating reusable logic (e.g., `use-toast` for notifications).
    *   **`lib/`**: Utility functions (e.g., `utils.ts` for `cn` helper).
    *   **`pages/`**: Top-level components representing different views or pages of the application (e.g., `Index.tsx` for the main game, `NotFound.tsx` for 404 errors).
    *   **`App.tsx`**: The root component of the React application.
    *   **`main.tsx`**: Entry point for the React application, rendering `App.tsx`.
    *   **`index.css`**: Global CSS styles, including Tailwind CSS imports and custom CSS variables.
*   **Configuration Files**: Files like `package.json`, `tailwind.config.ts`, `vite.config.ts`, `tsconfig.json`, `eslint.config.js`, and `vitest.config.ts` configure the project's build process, styling, TypeScript, linting, and testing environments.

## 3. Core Technologies and Dependencies

The project leverages a modern web development stack to provide a robust and interactive user experience. Here's a breakdown of the key technologies and their roles:

### 3.1 Frontend Framework: React

**React** is used as the primary JavaScript library for building the user interface. It enables the creation of reusable UI components and manages the application's state efficiently. The project uses functional components and React Hooks (`useState`, `useEffect`, `useCallback`, `useMemo`, `useRef`) for state management and lifecycle handling.

### 3.2 Language: TypeScript

**TypeScript** is a superset of JavaScript that adds static typing. This significantly improves code quality, readability, and maintainability by catching type-related errors during development. All `.tsx` and `.ts` files in the project are written in TypeScript, defining clear interfaces for data structures like `Piece`, `Move`, and `GameState`.

### 3.3 Build Tool: Vite

**Vite** is a fast build tool that provides a lightning-fast development experience. It's used for bundling the application, hot module replacement (HMR), and optimizing the build for production. The `vite.config.ts` file configures how Vite processes the project.

### 3.4 Styling: Tailwind CSS and Shadcn UI

*   **Tailwind CSS**: A utility-first CSS framework that allows for rapid UI development by composing classes directly in the markup. It's highly customizable, and the `tailwind.config.ts` file defines custom themes and colors, including specific colors for the chess board.
*   **Shadcn UI**: A collection of re-usable components built with Radix UI and Tailwind CSS. Instead of being a traditional component library, Shadcn UI provides the source code for components (e.g., `Button`, `Dialog`, `Switch`, `ScrollArea`), which are then integrated directly into the project. This allows for full control and customization. The `src/components/ui` directory contains these components.

### 3.5 Chess Engine and AI

*   **Custom Chess Engine**: The core chess logic is implemented in `src/engine/ChessEngine.ts`. This custom engine handles all aspects of chess rules, including move generation, validation, special moves (castling, en passant, promotion), and game state management.
*   **Custom AI Engine**: The AI opponent is implemented in `src/engine/AIEngine.ts`, utilizing the `ChessEngine` to calculate moves. It employs the Minimax algorithm with alpha-beta pruning and a custom evaluation function to determine the best moves.

### 3.6 Other Key Dependencies

*   **`@radix-ui/react-*`**: A suite of unstyled, accessible components used by Shadcn UI to build robust UI primitives (e.g., `Dialog`, `Switch`, `Accordion`).
*   **`lucide-react`**: A collection of beautiful and customizable SVG icons, used throughout the UI for various actions and indicators.
*   **`react-router-dom`**: Although not extensively used for multi-page navigation in this SPA, it's typically included for routing capabilities. In this project, it might be used for basic routing like the `NotFound` page.
*   **`date-fns`**: A modern JavaScript date utility library, likely used for formatting dates, for example, in PGN headers.
*   **`clsx` and `tailwind-merge`**: Utility libraries for conditionally joining CSS class names and merging Tailwind CSS classes intelligently, respectively.
*   **`@hookform/resolvers` and `zod`**: Used together for form validation. `react-hook-form` is a popular library for building forms, `zod` is a TypeScript-first schema declaration and validation library, and `@hookform/resolvers` integrates `zod` with `react-hook-form`.
*   **`@tanstack/react-query`**: A powerful data-fetching library for React. While not explicitly seen in the main game logic, it might be used for fetching external data if the application were to expand (e.g., user profiles, online game history). Its presence suggests a robust approach to data management.
*   **`embla-carousel-react`**: A carousel library for React, potentially used for displaying multiple board themes or piece styles in a carousel format within settings, though not directly observed in the provided code snippets.
*   **`sonner`**: A toast library for displaying notifications to the user.
*   **`react-resizable-panels`**: A component for creating resizable panel layouts, which could be used for adjusting the size of the board, move list, or captured pieces sections.
*   **`recharts`**: A composable charting library built with React and D3. This suggests potential future features for game analysis or statistics, or perhaps for visualizing AI evaluation scores.

### 3.7 Development Dependencies

*   **`eslint` and `typescript-eslint`**: For static code analysis and enforcing coding standards.
*   **`vitest` and `@testing-library/react`**: For unit and integration testing of components and logic.
*   **`autoprefixer` and `postcss`**: Tools for processing CSS, especially for adding vendor prefixes and enabling Tailwind CSS compilation.

## 4. Key Features and Implementation Details

This section delves into the core features of the `offline-chess-companion` and explains how they are implemented within the codebase.

### 4.1 Chess Engine (`src/engine/ChessEngine.ts`)

The `ChessEngine` class is the heart of the application, encapsulating all the rules and logic of chess. It manages the game state, generates legal moves, and determines game outcomes.

#### 4.1.1 Game State Representation (`types.ts`)

The `src/engine/types.ts` file defines the TypeScript interfaces and types that represent the chess game state:

*   **`PieceColor`**: `'w'` (white) or `'b'` (black).
*   **`PieceType`**: `'p'` (pawn), `'n'` (knight), `'b'` (bishop), `'r'` (rook), `'q'` (queen), `'k'` (king).
*   **`Piece`**: An object `{ color: PieceColor; type: PieceType; }`.
*   **`Square`**: `Piece | null` (a square can either contain a piece or be empty).
*   **`Board`**: `Square[][]` (an 8x8 2D array representing the chessboard).
*   **`Position`**: An object `{ row: number; col: number; }` for board coordinates.
*   **`Move`**: An object containing details about a move:
    *   `from`: `Position` (starting square).
    *   `to`: `Position` (destination square).
    *   `piece`: `Piece` (the piece being moved).
    *   `captured?`: `Piece` (optional, if a piece is captured).
    *   `promotion?`: `PieceType` (optional, if a pawn promotes).
    *   `isCastling?`: `'K'` or `'Q'` (optional, if the move is castling kingside or queenside).
    *   `isEnPassant?`: `boolean` (optional, if the move is an en passant capture).
    *   `san?`: `string` (optional, Standard Algebraic Notation of the move).
*   **`CastlingRights`**: `{ w: { K: boolean; Q: boolean }; b: { K: boolean; Q: boolean }; }` tracks castling availability for both colors.
*   **`GameState`**: The comprehensive state of the game:
    *   `board`: `Board`.
    *   `turn`: `PieceColor` (whose turn it is).
    *   `castlingRights`: `CastlingRights`.
    *   `enPassantTarget`: `Position | null` (square where en passant is possible).
    *   `halfMoveClock`: `number` (for 50-move rule).
    *   `fullMoveNumber`: `number` (move number, increments after black's move).
    *   `moveHistory`: `Move[]` (list of all moves made).
    *   `positionHistory`: `string[]` (list of FEN positions for repetition detection).
    *   `status`: `GameStatus` (e.g., 'active', 'check', 'checkmate', 'stalemate').

#### 4.1.2 FEN Parsing and Generation

*   **`parseFEN(fen: string): GameState`**: This method takes a Forsyth-Edwards Notation (FEN) string and converts it into a `GameState` object. FEN is a standard notation for describing a particular board position of a chess game.
    *   It parses the board arrangement, active color, castling availability, en passant target square, halfmove clock, and fullmove number.
    *   **Implementation**: It iterates through the FEN string, populating the `board` array and setting other `GameState` properties. Digits in FEN represent empty squares, while letters represent pieces (uppercase for white, lowercase for black).

    ```typescript
    // Example from ChessEngine.ts
    parseFEN(fen: string): GameState {
      const parts = fen.split(' ');
      const board: Board = [];
      const rows = parts[0].split('/');

      for (let r = 0; r < 8; r++) {
        board[r] = [];
        let col = 0;
        for (const ch of rows[r]) {
          if (/\d/.test(ch)) {
            for (let i = 0; i < parseInt(ch); i++) board[r][col++] = null;
          } else {
            const color: PieceColor = ch === ch.toUpperCase() ? 'w' : 'b';
            const type = ch.toLowerCase() as PieceType;
            board[r][col++] = { color, type };
          }
        }
      }
      // ... (rest of FEN parsing for turn, castling, en passant, clocks)
      return state;
    }
    ```

*   **`toFEN(state?: GameState): string`**: Converts the current or a given `GameState` back into a FEN string. This is crucial for saving game states and for repetition detection.

#### 4.1.3 Move Generation

The engine can generate all legal moves for a given piece or for the current player.

*   **`getLegalMoves(pos: Position): Move[]`**: Returns an array of all legal moves for the piece at the specified `pos`. A move is considered legal if it doesn't leave the king in check.
*   **`getAllLegalMoves(color?: PieceColor): Move[]`**: Returns all legal moves for all pieces of a given `color` (defaults to the current `turn`).
*   **`getPseudoMoves(pos: Position, state: GameState): Move[]`**: This private method generates 
all possible moves for a piece at `pos` without considering if the king would be in check. This is a helper for `getLegalMoves`.
    *   **Implementation**: It uses `switch` statements to handle different piece types (`pawn`, `knight`, `bishop`, `rook`, `queen`, `king`) and calls specialized helper functions like `getPawnMoves`, `getKnightMoves`, `getSlidingMoves`, and `getKingMoves`.

*   **`getPawnMoves(pos: Position, piece: Piece, state: GameState): Move[]`**: Calculates all pseudo-legal moves for a pawn, including single and double pushes, captures, en passant, and promotions.
    *   **Implementation**: It determines the pawn's direction based on its color, checks for empty squares for pushes, and checks for opponent pieces or en passant targets for captures. If a pawn reaches the promotion row, it generates moves for all possible promotion pieces (Queen, Rook, Bishop, Knight).

*   **`getKnightMoves(pos: Position, piece: Piece, state: GameState): Move[]`**: Calculates pseudo-legal moves for a knight based on its L-shaped movement pattern.
    *   **Implementation**: Uses a predefined array of `offsets` (e.g., `[-2,-1]`, `[-2,1]`) to determine target squares and checks if they are within board bounds and not occupied by a friendly piece.

*   **`getSlidingMoves(pos: Position, piece: Piece, state: GameState, dirs: number[][]): Move[]`**: A generic function used by bishops, rooks, and queens to calculate moves along straight or diagonal lines.
    *   **Implementation**: Iterates through given `dirs` (directions) and for each direction, it moves step-by-step until it hits another piece or the edge of the board. It adds empty squares as moves and captures an opponent's piece if encountered, then stops in that direction.

*   **`getKingMoves(pos: Position, piece: Piece, state: GameState): Move[]`**: Calculates pseudo-legal moves for a king, including normal moves and castling.
    *   **Implementation**: Similar to knights, it uses `offsets` for normal moves. For castling, it checks `castlingRights`, verifies that the squares between the king and rook are empty, and ensures the king does not move through or into check using `canCastle` and `isSquareAttacked` helper functions.

#### 4.1.4 Check and Attack Detection

*   **`isInCheck(color: PieceColor, state?: GameState): boolean`**: Determines if the king of the specified `color` is currently in check.
    *   **Implementation**: Finds the king's position and then calls `isSquareAttacked` to see if any opponent piece attacks that square.

*   **`isSquareAttacked(pos: Position, byDefender: PieceColor, state: GameState): boolean`**: Checks if a given `pos` is attacked by any piece of the opponent of `byDefender`.
    *   **Implementation**: Iterates through all squares on the board, and for each opponent piece, it generates its attack squares (a simplified version of pseudo-moves for attack detection) and checks if any of them match the target `pos`.

*   **`wouldBeInCheck(move: Move, state: GameState): boolean`**: Simulates a `move` and then checks if the king of the moving piece's color would be in check after that move. This is crucial for filtering out illegal moves.
    *   **Implementation**: Creates a temporary `newState` by applying the `move` and then calls `isInCheck` on this `newState`.

#### 4.1.5 Applying Moves and Updating Game State

*   **`makeMove(move: Move): boolean`**: Applies a `move` to the current game state, updating the board, turn, castling rights, en passant target, half-move clock, full-move number, and move history.
    *   **Implementation**: First, it validates the `move` against the legal moves. Then, it updates the board by moving the piece and handling captures, promotions, castling, and en passant. It also updates `castlingRights` if a king or rook moves, sets the `enPassantTarget` if a pawn moves two squares, and updates the `halfMoveClock` and `fullMoveNumber`. Finally, it computes the new `GameStatus` and generates the Standard Algebraic Notation (SAN) for the move.

#### 4.1.6 Game Status Computation

*   **`computeStatus(state: GameState): GameStatus`**: Determines the current status of the game (e.g., active, check, checkmate, stalemate, draw).
    *   **Implementation**: Checks if there are any legal moves available for the current player. If not, it determines if it's a checkmate (if the king is in check) or a stalemate (if the king is not in check). It also checks for the 50-move rule and threefold repetition to determine draw conditions.

#### 4.1.7 Standard Algebraic Notation (SAN)

*   **`moveToSAN(move: Move): string`**: Converts a `Move` object into its Standard Algebraic Notation (SAN) string representation.
    *   **Implementation**: Handles special cases like castling (`O-O`, `O-O-O`). For other moves, it constructs the SAN string based on the piece type, starting and ending squares, captures (`x`), and promotions (`=Q`). It also includes logic for disambiguation (e.g., `Nbd2` vs `Nfd2`) if multiple pieces can move to the same square.

*   **`sanToMove(san: string): Move | null`**: Converts a SAN string back into a `Move` object. This is used for PGN import.
    *   **Implementation**: Iterates through all legal moves and compares their generated SAN with the input SAN to find a match.

#### 4.1.8 Undo/Redo Functionality

*   **`undo(): boolean`**: Reverts the last move made, restoring the previous game state.
    *   **Implementation**: It pops the last move from `moveHistory`, pushes it to `undoneHistory`, and then rebuilds the game state by replaying all moves except the last one from the initial FEN. This approach ensures a consistent state after undoing.

*   **`redo(): boolean`**: Reapplies a previously undone move.
    *   **Implementation**: It pops a move from `undoneHistory` and applies it using `makeMove`.

#### 4.1.9 PGN Import/Export

*   **`toPGN(): string`**: Generates the Portable Game Notation (PGN) string for the current game.
    *   **Implementation**: Constructs PGN headers (Event, Site, Date, White, Black, Result) and then iterates through the `moveHistory` to append each move's SAN to the PGN string, including move numbers and the final game result.

*   **`loadPGN(pgn: string): boolean`**: Loads a game from a PGN string.
    *   **Implementation**: Parses the PGN string to extract the move sequence. It then resets the engine to the initial state and attempts to `makeMove` for each move in the PGN sequence. If any move is illegal or parsing fails, it returns `false`.

*   **`resign(): void`**: Sets the game status to `resigned`.

*   **`timeout(color: PieceColor): void`**: Sets the game status to `timeout` for the specified color.

*   **`reset(fen?: string): void`**: Resets the game to the initial position or a specified FEN string.

### 4.2 AI Engine (`src/engine/AIEngine.ts`)

The `AIEngine` is responsible for calculating the AI's moves based on the current game state and a specified difficulty level. It employs a classic search algorithm: Minimax with Alpha-Beta Pruning.

#### 4.2.1 Piece Values and Positional Tables

*   **`PIECE_VALUES`**: A constant object defining the material value of each piece type (e.g., Pawn: 100, Knight: 320, Queen: 900). These values are fundamental for the evaluation function.

*   **Positional Tables (`PAWN_TABLE`, `KNIGHT_TABLE`, etc.)**: These are 8x8 arrays that assign bonus or penalty points to pieces based on their position on the board. For example, pawns in the center might get a higher score, while knights on the edge might get a lower score. These tables are defined from white's perspective and are mirrored for black pieces.

*   **`TABLES`**: An object mapping `PieceType` to its corresponding positional table.

#### 4.2.2 Board Evaluation Function (`evaluateBoard(engine: ChessEngine): number`)

This function calculates a numerical score for a given `ChessEngine` state, representing how favorable the position is for white. A higher positive score means a better position for white, and a lower negative score means a better position for black.

*   **Implementation**: It iterates through all pieces on the board. For each piece, it adds its `PIECE_VALUES` and its positional score from the relevant `TABLES`. The positional score is adjusted based on the piece's color (mirrored for black). The sum of these values gives the total board evaluation.

#### 4.2.3 Difficulty Levels and Search Depth

*   **`Difficulty`**: An enum (`easy`, `medium`, `hard`) defined in `types.ts`.
*   **`getDepthForDifficulty(difficulty: Difficulty): number`**: Maps the difficulty level to a search depth for the Minimax algorithm.
    *   `easy`: depth 1 (AI only looks one move ahead).
    *   `medium`: depth 3.
    *   `hard`: depth 4.

#### 4.2.4 Minimax Algorithm with Alpha-Beta Pruning (`minimax` function)

This is the core search algorithm used by the AI to find the best move. Minimax is a recursive algorithm used for decision-making in game theory, aiming to maximize the score for the AI's turn and minimize the score for the opponent's turn.

*   **`minimax(engine: ChessEngine, depth: number, alpha: number, beta: number, isMaximizing: boolean): number`**: Recursively explores the game tree to find the optimal move.
    *   **`depth`**: The remaining search depth. When `depth` is 0 or the game is over, the function returns the `evaluateBoard` score.
    *   **`alpha`**: The best score that the maximizing player (AI) can guarantee at the current level or above.
    *   **`beta`**: The best score that the minimizing player (opponent) can guarantee at the current level or above.
    *   **`isMaximizing`**: A boolean indicating if the current call is for the maximizing player (AI) or minimizing player (opponent).
    *   **Alpha-Beta Pruning**: This optimization technique prunes branches of the search tree that cannot possibly influence the final decision, significantly reducing the number of nodes to evaluate.
        *   If `beta <= alpha`, the current branch is pruned.

#### 4.2.5 `getAIMove(engine: ChessEngine, difficulty: Difficulty): Move | null`

This is the main function called to get the AI's move.

*   **Implementation**: It first gets all legal moves from the `ChessEngine`. For 'easy' difficulty, it introduces some randomness. For other difficulties, it calls the `minimax` function to evaluate each legal move and selects the move that yields the best score for the AI. Moves are sorted (captures first) to improve alpha-beta pruning efficiency.

### 4.3 User Interface Components (`src/components/chess/`)

The `src/components/chess/` directory contains the React components that render the chess board, pieces, controls, and other UI elements.

#### 4.3.1 `Board.tsx`

This component is responsible for rendering the 8x8 chessboard and handling user interactions (clicks, drags) for making moves.

*   **Props**: `engine` (ChessEngine instance), `settings` (GameSettings), `flipped` (boolean for board orientation), `onMove` (callback for move completion), `disabled` (boolean to disable interaction).
*   **State**: `selectedPos` (currently selected square), `legalMoves` (legal moves for the selected piece), `promotionMove` (details for pawn promotion dialog), `dragFrom` (starting square of a drag operation).
*   **`handleSquareClick`**: Manages square selection and move attempts. If a piece is selected, it highlights legal moves. If a second square is clicked, it attempts to make a move. Handles pawn promotion by setting `promotionMove`.
*   **`handleDragStart` / `handleDrop`**: Implements drag-and-drop functionality for pieces. When a piece is dragged, it highlights legal drop targets. On drop, it attempts to make the move, similar to `handleSquareClick`.
*   **Rendering**: Iterates through rows and columns to render `SquareComponent` for each square. It passes various props to `SquareComponent` to determine its appearance (light/dark, selected, legal move, last move, check, coordinates).
*   **`PromotionDialog`**: A sub-component rendered when a pawn reaches the promotion rank, allowing the user to choose a promotion piece.

#### 4.3.2 `SquareComponent.tsx`

Represents a single square on the chessboard.

*   **Props**: `row`, `col`, `isLight`, `isSelected`, `isLegalMove`, `isLastMove`, `isCheck`, `showCoordinates`, `theme`, `onClick`, `onDragOver`, `onDrop`, `children` (for `PieceDisplay`), `onDragStart`, `draggable`, `ariaLabel`.
*   **Styling**: Uses Tailwind CSS classes and CSS variables (defined in `src/index.css` and `tailwind.config.ts`) to apply different board themes (`classic`, `dark`, `wood`) and highlight states (selected, legal move, last move, check).
*   **Coordinates**: Renders file and rank coordinates on the edges of the board if `showCoordinates` is enabled.
*   **Legal Move Indicators**: Displays a small dot for legal moves to empty squares and a ring for legal moves to occupied squares.

#### 4.3.3 `PieceDisplay.tsx`

Renders a single chess piece.

*   **Props**: `type` (PieceType), `color` (PieceColor), `style` (PieceStyle), `isDragging`.
*   **Piece Styles**: Supports `staunton` (Unicode chess symbols) and `minimal` (text characters) styles. The symbols are defined in `STAUNTON` and `MINIMAL` constant objects.
*   **Styling**: Applies appropriate text color based on `piece.color` and a `transition-transform` for drag animations.

#### 4.3.4 `CapturedPieces.tsx`

Displays the pieces captured by each player.

*   **Props**: `moves` (move history), `pieceStyle`.
*   **Implementation**: Iterates through the `moves` history to identify captured pieces. It groups captured pieces by color and sorts them by value (Queen > Rook > Bishop/Knight > Pawn). It also calculates and displays the material advantage.

#### 4.3.5 `MoveList.tsx`

Shows the history of moves made in the game.

*   **Props**: `moves` (move history), `currentIndex` (for highlighting the current move), `onJumpTo` (callback to navigate to a specific move in history).
*   **Implementation**: Formats the `moves` array into pairs (white's move, black's move) and displays them with move numbers and their SAN. Uses `ScrollArea` from Shadcn UI for scrollability.

#### 4.3.6 `ChessTimer.tsx`

Implements the chess clock functionality.

*   **Props**: `clockMode` (`none`, `blitz`, `rapid`, `custom`), `activeTurn`, `gameOver`, `onTimeout` (callback when a player runs out of time), `resetKey` (to force reset timer).
*   **State**: `whiteTime`, `blackTime` (remaining time in seconds).
*   **`useEffect`**: Sets up a `setInterval` to decrement the active player's time every second. When time runs out, it calls `onTimeout`.
*   **`getInitialTime`**: Returns the starting time based on the `clockMode`.
*   **`formatTime`**: Formats seconds into `MM:SS` string.

#### 4.3.7 `GameControls.tsx`

Provides buttons for game actions like New Game, Undo, Redo, Resign, Restart, and Settings.

*   **Props**: Callbacks for each action (`onNewGame`, `onUndo`, etc.) and booleans to control button `disabled` states (`canUndo`, `canRedo`, `gameOver`).
*   **Icons**: Uses `lucide-react` icons for visual representation of actions.

#### 4.3.8 `NewGameDialog.tsx`

A dialog for configuring and starting a new game.

*   **State**: `mode` (`ai` or `local`), `difficulty`, `playerColor`, `clockMode`.
*   **Implementation**: Uses Shadcn UI `Dialog` components. Provides options for selecting game mode, AI difficulty, player color (for AI mode), and clock mode using `Chip` components for a clean selection interface. Calls `onStart` with the selected options when the 
Start Game button is clicked.

#### 4.3.9 `SettingsPanel.tsx`

A dialog for adjusting various game settings.

*   **Props**: `open`, `onClose`, `settings` (current settings), `onChange` (callback to update settings).
*   **Implementation**: Uses Shadcn UI `Dialog` components. Allows users to change:
    *   **Board Theme**: `classic`, `dark`, `wood` (defined in `tailwind.config.ts` and `src/index.css`).
    *   **Piece Style**: `staunton` (Unicode symbols) or `minimal` (text characters).
    *   **Toggle Switches**: For `soundEnabled`, `showLegalMoves`, `showLastMove`, `showCoordinates`, and `highContrast`. These settings directly influence the visual feedback and user experience of the game.
*   **Persistence**: Settings are saved to `localStorage` using a `useEffect` hook in `Index.tsx`, ensuring they persist across sessions.

#### 4.3.10 `PGNDialog.tsx`

A dialog for importing and exporting games in PGN format.

*   **Props**: `open`, `onClose`, `pgn` (current game PGN string), `onImport` (callback to load a PGN string).
*   **Implementation**: Features two tabs: Export and Import.
    *   **Export**: Displays the current game's PGN in a `Textarea` and provides a 
Download .pgn button to save the PGN to a file.
    *   **Import**: Provides a `Textarea` for users to paste a PGN string and a Load Game button to import it. The `onImport` callback uses the `ChessEngine.loadPGN` method.

#### 4.3.11 `PromotionDialog.tsx`

This component is displayed when a pawn reaches the opponent's back rank, allowing the player to choose which piece it promotes to.

*   **Props**: `color` (color of the pawn promoting), `pieceStyle`, `onSelect` (callback with the chosen piece type), `onCancel`.
*   **Implementation**: Presents buttons for Queen, Rook, Bishop, and Knight. When a piece is selected, `onSelect` is called, and the dialog closes.

#### 4.3.12 `NavLink.tsx` (in `src/components/`)

A simple navigation link component, likely used for routing within the application, though its usage isn't explicitly detailed in the `Index.tsx` snippet.

#### 4.3.13 `GameControls.tsx`

This component provides interactive buttons for managing the game state, such as starting a new game, undoing/redoing moves, resigning, and accessing settings.

*   **Props**: `onNewGame`, `onUndo`, `onRedo`, `onResign`, `onRestart`, `onSettings` (callback functions for each action), `canUndo`, `canRedo`, `gameOver` (boolean flags to enable/disable buttons).
*   **Implementation**: Each button is a Shadcn UI `Button` component, styled with Tailwind CSS and featuring `lucide-react` icons for clear visual cues. The `disabled` prop is dynamically set based on the game state to prevent invalid actions.

### 4.4 Custom Hooks (`src/hooks/`)

Custom React hooks are used to encapsulate reusable logic, making components cleaner and more focused on rendering.

#### 4.4.1 `use-mobile.tsx`

This hook is likely used to detect if the application is running on a mobile device or a small screen, allowing for responsive UI adjustments. (Not directly used in `Index.tsx` but a common pattern).

#### 4.4.2 `use-toast.ts`

This hook provides an interface for displaying toast notifications to the user.

*   **Implementation**: It likely wraps a toast library (like `sonner` as seen in `package.json`) and provides a `toast` function that can be called from any component to show messages (e.g., 
PGN loaded successfully, Failed to load PGN).

### 4.5 Utilities (`src/lib/utils.ts`)

#### 4.5.1 `cn` function

The `src/lib/utils.ts` file typically contains utility functions. In this project, it exports a `cn` function, which is a common pattern in Tailwind CSS projects using `clsx` and `tailwind-merge`.

*   **`cn(...inputs: ClassValue[])`**: This function is a wrapper around `clsx` and `tailwind-merge`.
    *   **`clsx`**: A tiny utility for constructing `className` strings conditionally. It allows you to pass multiple arguments, which can be strings, objects, or arrays, and it intelligently combines them into a single class string.
    *   **`tailwind-merge`**: A utility that merges Tailwind CSS classes without style conflicts. For example, if you have `"p-4 p-6"`, `tailwind-merge` will resolve it to `"p-6"`, ensuring that the most specific class takes precedence.
*   **Purpose**: The `cn` function simplifies the process of building dynamic and conditional CSS class strings in React components, especially when working with Tailwind CSS, preventing common styling issues.

### 4.6 Main Application Flow (`src/pages/Index.tsx` and `src/main.tsx`)

#### 4.6.1 `main.tsx`

This is the entry point of the React application.

*   **Implementation**: It uses `ReactDOM.createRoot` to render the `App` component into the HTML element with the ID `root` (found in `index.html`). It also wraps the `App` in `React.StrictMode` for highlighting potential problems in an application.

#### 4.6.2 `Index.tsx`

The `Index.tsx` component is the main view of the chess application, orchestrating all other components and managing the overall game state.

*   **State Management**: Uses `useState` and `useCallback` hooks to manage various aspects of the game:
    *   `engine`: An instance of `ChessEngine` to manage the chess game logic.
    *   `settings`: User preferences for the board and pieces, loaded from `localStorage`.
    *   `showNewGame`, `showSettings`, `showPGN`: Booleans to control the visibility of dialogs.
    *   `gameMode`, `difficulty`, `playerColor`, `clockMode`: Settings for the current game.
    *   `aiThinking`: A boolean to indicate when the AI is calculating its move.
*   **`useEffect` for AI Moves**: A `useEffect` hook monitors the `engine.getTurn()`, `gameMode`, `playerColor`, and `engine.isGameOver()` to trigger AI moves. If it's the AI's turn, it calls `getAIMove` from `AIEngine.ts` after a short delay and then updates the game state.
*   **Event Handlers**: Contains `useCallback` wrapped functions for handling user interactions:
    *   `handleMove`: Called when a player makes a move on the board.
    *   `handleNewGame`: Initializes a new game with selected options.
    *   `handleUndo`, `handleRedo`, `handleResign`, `handleRestart`: Call corresponding methods on the `ChessEngine` instance.
    *   `handleTimeout`: Called by `ChessTimer` when a player runs out of time.
    *   `handlePGNImport`: Imports a game from a PGN string.
*   **Status Display**: Uses `useMemo` to compute a human-readable `statusText` based on the current `engine.getState().status` (e.g., 
Checkmate!, Stalemate, White to move).
*   **Layout**: The component structures the main layout of the application, including the header, the chess board section, and the side panel containing captured pieces, move list, and game controls.

## 5. Configuration Files

This section details the purpose and configuration of various project files that manage the build process, styling, and development environment.

### 5.1 `package.json`

This file defines the project's metadata, scripts, and dependencies.

*   **`name`**: `"vite_react_shadcn_ts"` - The name of the project.
*   **`private`**: `true` - Indicates that the package is not intended to be published to a registry.
*   **`version`**: `"0.0.0"` - The current version of the project.
*   **`type`**: `"module"` - Specifies that the project uses ES modules.
*   **`scripts`**: Defines various command-line scripts for common tasks:
    *   `dev`: `"vite"` - Starts the development server using Vite.
    *   `build`: `"vite build"` - Builds the project for production.
    *   `build:dev`: `"vite build --mode development"` - Builds the project in development mode.
    *   `lint`: `"eslint ."` - Runs ESLint to check for code quality issues.
    *   `preview`: `"vite preview"` - Serves the production build locally for previewing.
    *   `test`: `"vitest run"` - Runs tests once using Vitest.
    *   `test:watch`: `"vitest"` - Runs tests in watch mode.
*   **`dependencies`**: Lists the production dependencies required by the application (e.g., React, Radix UI components, `lucide-react`, `date-fns`, `clsx`, `tailwind-merge`, `react-hook-form`, `zod`, `@tanstack/react-query`, `embla-carousel-react`, `sonner`, `react-resizable-panels`, `recharts`). These are the libraries that the application needs to run in a deployed environment.
*   **`devDependencies`**: Lists the development dependencies, which are only needed during development and testing (e.g., `@vitejs/plugin-react-swc`, `autoprefixer`, `eslint`, `postcss`, `tailwindcss`, `typescript`, `vitest`, `@testing-library/react`).

### 5.2 `tailwind.config.ts`

This is the configuration file for Tailwind CSS, where custom styles, themes, and plugins are defined.

*   **`darkMode`**: `["class"]` - Configures dark mode to be toggled by a `dark` class on the `html` element.
*   **`content`**: Specifies the files that Tailwind should scan for class names to generate the necessary CSS. This ensures that only used utility classes are included in the final build, optimizing file size.
*   **`theme.extend.colors`**: Defines custom color palettes, including specific colors for the chess board themes (`chess-classic-light`, `chess-classic-classic-dark`, `chess-dark-light`, `chess-dark-dark`, `chess-wood-light`, `chess-wood-dark`) and piece colors (`chess-white-piece`, `chess-black-piece`). These custom colors are then used in components like `SquareComponent`.
*   **`theme.extend.borderRadius`**: Defines custom border-radius values using CSS variables.
*   **`theme.extend.keyframes` and `theme.extend.animation`**: Defines custom CSS keyframes and animations, such as for accordion components.
*   **`plugins`**: Includes Tailwind CSS plugins, such as `tailwindcss-animate` for animations.

### 5.3 `postcss.config.js`

PostCSS is a tool for transforming CSS with JavaScript plugins. This configuration is typically used to integrate Tailwind CSS and Autoprefixer.

*   **`plugins`**: Specifies the PostCSS plugins to use:
    *   `tailwindcss`: Integrates Tailwind CSS into the build process.
    *   `autoprefixer`: Automatically adds vendor prefixes to CSS rules, ensuring compatibility across different browsers.

### 5.4 `vite.config.ts`

This is the configuration file for Vite, the build tool.

*   **`plugins`**: Specifies Vite plugins, such as `@vitejs/plugin-react-swc` for fast React development with SWC (Speedy Web Compiler).
*   **`resolve.alias`**: Configures path aliases (e.g., `@` maps to `src`), simplifying import paths in the codebase.

### 5.5 `tsconfig.json`, `tsconfig.app.json`, `tsconfig.node.json`

These files configure the TypeScript compiler for different parts of the project.

*   **`tsconfig.json`**: The base TypeScript configuration, defining common compiler options.
*   **`tsconfig.app.json`**: Extends `tsconfig.json` and specifies settings for the application code (e.g., `jsx: "react-jsx"`, `lib: ["DOM", "DOM.Iterable", "ESNext"]`).
*   **`tsconfig.node.json`**: Extends `tsconfig.json` and specifies settings for Node.js-specific files, such as Vite configuration or test setup files.

### 5.6 `eslint.config.js`

This file configures ESLint, a static code analysis tool for identifying problematic patterns found in JavaScript/TypeScript code.

*   **`plugins`**: Specifies ESLint plugins, such as `@typescript-eslint` for TypeScript-specific rules and `react-hooks` for rules related to React Hooks.
*   **`rules`**: Defines specific linting rules and their severity levels.

### 5.7 `vitest.config.ts`

This file configures Vitest, a fast unit-test framework powered by Vite.

*   **`plugins`**: Includes Vite plugins, similar to `vite.config.ts`.
*   **`test`**: Defines Vitest-specific options, such as:
    *   `environment: "jsdom"`: Configures the test environment to simulate a browser DOM.
    *   `setupFiles`: Specifies setup files to run before each test (e.g., `src/test/setup.ts`).
    *   `globals: true`: Makes Vitest APIs globally available.

## 6. Conclusion

The `Ezra003/offline-chess-companion` project is a well-structured and feature-rich web application that provides a complete offline chess experience. It demonstrates the effective use of modern web technologies, including React, TypeScript, Vite, and Tailwind CSS, to build an interactive and maintainable user interface.

The core of the application lies in its custom `ChessEngine`, which meticulously implements chess rules, move generation, and game state management. The `AIEngine` further enhances the user experience by providing an intelligent AI opponent with adjustable difficulty levels, leveraging the Minimax algorithm with alpha-beta pruning and a sophisticated evaluation function.

The modular component architecture, combined with custom hooks and utility functions, promotes code reusability and maintainability. The comprehensive configuration for building, styling, linting, and testing ensures a robust development workflow.

This documentation aims to provide a clear and in-depth understanding of the project, enabling new developers to quickly grasp its functionalities and contribute to its future development. The detailed explanations of the chess engine, AI, UI components, and configuration files should serve as a valuable resource for anyone looking to explore or extend this offline chess companion.

## 7. References

[1] GitHub Repository: [Ezra003/offline-chess-companion](https://github.com/Ezra003/offline-chess-companion)
[2] React Documentation: [https://react.dev/](https://react.dev/)
[3] TypeScript Documentation: [https://www.typescriptlang.org/docs/](https://www.typescriptlang.org/docs/)
[4] Vite Documentation: [https://vitejs.dev/](https://vitejs.dev/)
[5] Tailwind CSS Documentation: [https://tailwindcss.com/docs](https://tailwindcss.com/docs)
[6] Shadcn UI Documentation: [https://ui.shadcn.com/docs](https://ui.shadcn.com/docs)
[7] Radix UI Documentation: [https://www.radix-ui.com/](https://www.radix-ui.com/)
[8] Lucide React Icons: [https://lucide.dev/](https://lucide.dev/)
[9] date-fns Documentation: [https://date-fns.org/](https://date-fns.org/)
[10] clsx GitHub: [https://github.com/lukeed/clsx](https://github.com/lukeed/clsx)
[11] tailwind-merge GitHub: [https://github.com/dcastil/tailwind-merge](https://github.com/dcastil/tailwind-merge)
[12] React Hook Form Documentation: [https://react-hook-form.com/](https://react-hook-form.com/)
[13] Zod Documentation: [https://zod.dev/](https://zod.dev/)
[14] TanStack Query Documentation: [https://tanstack.com/query/latest](https://tanstack.com/query/latest)
[15] Embla Carousel React: [https://www.embla-carousel.com/](https://www.embla-carousel.com/)
[16] Sonner GitHub: [https://github.com/emilkowalski/sonner](https://github.com/emilkowalski/sonner)
[17] React Resizable Panels: [https://react-resizable-panels.vercel.app/](https://react-resizable-panels.vercel.app/)
[18] Recharts Documentation: [https://recharts.org/en-US/](https://recharts.org/en-US/)
[19] ESLint Documentation: [https://eslint.org/docs/latest/](https://eslint.org/docs/latest/)
[20] Vitest Documentation: [https://vitest.dev/](https://vitest.dev/)
[21] PostCSS Documentation: [https://postcss.org/](https://postcss.org/)
[22] Autoprefixer GitHub: [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)
[23] Minimax Algorithm: [https://en.wikipedia.org/wiki/Minimax](https://en.wikipedia.org/wiki/Minimax)
[24] Alpha-Beta Pruning: [https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning)
[25] Forsyth-Edwards Notation (FEN): [https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation](https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation)
[26] Standard Algebraic Notation (SAN): [https://en.wikipedia.org/wiki/Algebraic_notation_(chess)#Standard_Algebraic_Notation](https://en.wikipedia.org/wiki/Algebraic_notation_(chess)#Standard_Algebraic_Notation)
